from django.contrib.auth.models import User
from django.core.validators import MaxValueValidator, MinValueValidator
from django.db import models
from django.utils import timezone
from django.utils.text import slugify


class DiscoveryProject(models.Model):
    """
    Represents a scientific discovery project created by a user.
    """

    DOMAIN_CHOICES = [
        ("mathematics", "Mathematics"),
        ("physics", "Physics"),
        ("chemistry", "Chemistry"),
        ("biology", "Biology"),
        ("computer_science", "Computer Science"),
        ("materials_science", "Materials Science"),
        ("social_sciences", "Social Sciences"),
        ("interdisciplinary", "Interdisciplinary"),
    ]

    STATUS_CHOICES = [
        ("active", "Active"),
        ("paused", "Paused"),
        ("completed", "Completed"),
        ("archived", "Archived"),
    ]

    user = models.ForeignKey(User, on_delete=models.CASCADE, related_name="discovery_projects")
    title = models.CharField(max_length=255)
    slug = models.SlugField(max_length=255, unique=True, blank=True)
    description = models.TextField(help_text="Describe the problem area or research question")
    domain = models.CharField(max_length=50, choices=DOMAIN_CHOICES)
    status = models.CharField(max_length=20, choices=STATUS_CHOICES, default="active")
    created_at = models.DateTimeField(auto_now_add=True)
    updated_at = models.DateTimeField(auto_now=True)
    is_public = models.BooleanField(default=False, help_text="Make this project visible to other users")

    class Meta:
        ordering = ["-created_at"]
        indexes = [
            models.Index(fields=["user", "status"]),
            models.Index(fields=["domain"]),
        ]

    def __str__(self):
        return f"{self.title} ({self.domain})"

    def save(self, *args, **kwargs):
        if not self.slug:
            self.slug = slugify(self.title)
            # Ensure uniqueness
            original_slug = self.slug
            counter = 1
            while DiscoveryProject.objects.filter(slug=self.slug).exists():
                self.slug = f"{original_slug}-{counter}"
                counter += 1
        super().save(*args, **kwargs)


class Hypothesis(models.Model):
    """
    Represents a hypothesis generated by the AI or proposed by the user.
    """

    STATUS_CHOICES = [
        ("proposed", "Proposed"),
        ("testing", "Testing"),
        ("supported", "Supported"),
        ("rejected", "Rejected"),
        ("refined", "Refined"),
    ]

    project = models.ForeignKey(DiscoveryProject, on_delete=models.CASCADE, related_name="hypotheses")
    statement = models.TextField(help_text="The hypothesis statement")
    rationale = models.TextField(blank=True, help_text="Reasoning behind this hypothesis")
    status = models.CharField(max_length=20, choices=STATUS_CHOICES, default="proposed")
    confidence_score = models.FloatField(
        default=0.0,
        help_text="AI confidence in this hypothesis (0-1)",
        validators=[MinValueValidator(0.0), MaxValueValidator(1.0)],
    )
    is_ai_generated = models.BooleanField(default=True)
    created_at = models.DateTimeField(auto_now_add=True)
    updated_at = models.DateTimeField(auto_now=True)
    parent_hypothesis = models.ForeignKey(
        "self", on_delete=models.SET_NULL, null=True, blank=True, related_name="refined_hypotheses"
    )

    class Meta:
        ordering = ["-created_at"]
        verbose_name_plural = "Hypotheses"

    def __str__(self):
        return f"{self.statement[:100]}... ({self.status})"


class Experiment(models.Model):
    """
    Represents an experiment or test to validate a hypothesis.
    """

    EXPERIMENT_TYPE_CHOICES = [
        ("simulation", "Simulation"),
        ("computation", "Computation"),
        ("theorem_proving", "Theorem Proving"),
        ("data_analysis", "Data Analysis"),
        ("literature_search", "Literature Search"),
        ("physical", "Physical Experiment (Proposed)"),
    ]

    STATUS_CHOICES = [
        ("planned", "Planned"),
        ("running", "Running"),
        ("completed", "Completed"),
        ("failed", "Failed"),
    ]

    hypothesis = models.ForeignKey(Hypothesis, on_delete=models.CASCADE, related_name="experiments")
    experiment_type = models.CharField(max_length=50, choices=EXPERIMENT_TYPE_CHOICES)
    description = models.TextField(help_text="Experimental setup and methodology")
    parameters = models.JSONField(default=dict, help_text="Experiment parameters and configuration")
    status = models.CharField(max_length=20, choices=STATUS_CHOICES, default="planned")
    results = models.JSONField(null=True, blank=True, help_text="Experimental results and data")
    started_at = models.DateTimeField(null=True, blank=True)
    completed_at = models.DateTimeField(null=True, blank=True)
    created_at = models.DateTimeField(auto_now_add=True)

    class Meta:
        ordering = ["-created_at"]

    def __str__(self):
        return f"{self.experiment_type} for {self.hypothesis.statement[:50]}..."


class Discovery(models.Model):
    """
    Represents a significant finding or discovery made through the AI engine.
    """

    SIGNIFICANCE_CHOICES = [
        ("minor", "Minor Finding"),
        ("moderate", "Moderate Discovery"),
        ("significant", "Significant Discovery"),
        ("breakthrough", "Breakthrough"),
    ]

    project = models.ForeignKey(DiscoveryProject, on_delete=models.CASCADE, related_name="discoveries")
    hypothesis = models.ForeignKey(Hypothesis, on_delete=models.CASCADE, related_name="discoveries")
    title = models.CharField(max_length=255)
    summary = models.TextField(help_text="Brief summary of the discovery")
    detailed_report = models.TextField(help_text="Comprehensive report of findings")
    significance = models.CharField(max_length=20, choices=SIGNIFICANCE_CHOICES, default="minor")
    supporting_data = models.JSONField(default=dict, help_text="Supporting experimental data and evidence")
    citations = models.JSONField(default=list, help_text="Relevant citations and references")
    created_at = models.DateTimeField(auto_now_add=True)
    is_verified = models.BooleanField(default=False, help_text="Verified by human expert")

    class Meta:
        ordering = ["-created_at"]
        verbose_name_plural = "Discoveries"

    def __str__(self):
        return f"{self.title} - {self.significance}"


class KnowledgeBase(models.Model):
    """
    Stores scientific knowledge, papers, and data for the AI to reference.
    """

    CONTENT_TYPE_CHOICES = [
        ("paper", "Research Paper"),
        ("textbook", "Textbook"),
        ("database", "Database Entry"),
        ("theorem", "Mathematical Theorem"),
        ("experimental_data", "Experimental Data"),
    ]

    title = models.CharField(max_length=500)
    content_type = models.CharField(max_length=50, choices=CONTENT_TYPE_CHOICES)
    domain = models.CharField(max_length=50, choices=DiscoveryProject.DOMAIN_CHOICES)
    abstract = models.TextField(blank=True)
    content = models.TextField(help_text="Full content or reference")
    metadata = models.JSONField(default=dict, help_text="Authors, publication date, DOI, etc.")
    embedding_vector = models.JSONField(null=True, blank=True, help_text="Vector embedding for semantic search")
    created_at = models.DateTimeField(auto_now_add=True)
    updated_at = models.DateTimeField(auto_now=True)

    class Meta:
        ordering = ["-created_at"]
        indexes = [
            models.Index(fields=["domain", "content_type"]),
        ]

    def __str__(self):
        return f"{self.title} ({self.content_type})"


class IterationLog(models.Model):
    """
    Logs each iteration of the discovery process for a hypothesis.
    """

    hypothesis = models.ForeignKey(Hypothesis, on_delete=models.CASCADE, related_name="iteration_logs")
    iteration_number = models.IntegerField()
    action = models.CharField(
        max_length=50,
        choices=[
            ("generated", "Hypothesis Generated"),
            ("tested", "Hypothesis Tested"),
            ("refined", "Hypothesis Refined"),
            ("rejected", "Hypothesis Rejected"),
            ("supported", "Hypothesis Supported"),
        ],
    )
    details = models.TextField()
    ai_reasoning = models.TextField(blank=True, help_text="AI's reasoning for this action")
    created_at = models.DateTimeField(auto_now_add=True)

    class Meta:
        ordering = ["hypothesis", "iteration_number"]

    def __str__(self):
        return f"Iteration {self.iteration_number}: {self.action} for {self.hypothesis.statement[:50]}..."
