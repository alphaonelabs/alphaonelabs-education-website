# Generated by Django 5.1.6 on 2025-04-01 16:15

from typing import Any

from django.db import connection, migrations, models
from django.utils.text import slugify


def populate_meme_slugs(apps: Any, schema_editor: Any) -> None:
    """Populate slug values for all memes that don't have one."""
    Meme = apps.get_model("web", "Meme")
    # Filter only empty slugs (in case this runs after the column was already added)
    for meme in Meme.objects.all():
        if not meme.slug:
            slug = slugify(meme.title)
            original_slug = slug
            counter = 1
            while Meme.objects.filter(slug=slug).exists():
                slug = f"{original_slug}-{counter}"
                counter += 1
            meme.slug = slug
            meme.save()


def add_slug_column_if_not_exists(apps, schema_editor):
    """Add the slug column if it doesn't exist already."""
    vendor = connection.vendor

    # Skip this step if we're faking the migration
    if schema_editor.connection.alias == "default" and not schema_editor._constraint_names:
        return

    try:
        # Check if the column already exists
        with connection.cursor() as cursor:
            table_name = "web_meme"
            column_name = "slug"

            if vendor == "sqlite":
                cursor.execute(f"PRAGMA table_info({table_name})")
                columns = [info[1] for info in cursor.fetchall()]
                if column_name in columns:
                    return
                cursor.execute(f"ALTER TABLE {table_name} ADD COLUMN {column_name} VARCHAR(255) DEFAULT ''")

            elif vendor == "mysql":
                cursor.execute(f"SHOW COLUMNS FROM {table_name} LIKE '{column_name}'")
                if cursor.fetchone():
                    return
                cursor.execute(f"ALTER TABLE {table_name} ADD COLUMN {column_name} VARCHAR(255) DEFAULT ''")

            elif vendor == "postgresql":
                # Add column if not exists for PostgreSQL
                cursor.execute(
                    f"ALTER TABLE {table_name} ADD COLUMN IF NOT EXISTS {column_name} VARCHAR(255) DEFAULT ''"
                )
    except Exception:
        # If there's any error, let the migration continue
        # The field might already exist or the table might not exist yet
        pass


def handle_unique_constraint(apps, schema_editor):
    """Create the unique constraint and index in a database-agnostic way."""
    vendor = connection.vendor

    # Skip this step if we're faking the migration
    if schema_editor.connection.alias == "default" and not schema_editor._constraint_names:
        return

    try:
        with connection.cursor() as cursor:
            table_name = "web_meme"
            column_name = "slug"
            index_name = "web_meme_slug_7c5abfde_like"
            constraint_name = "web_meme_slug_key"

            # Drop the existing indices first to avoid conflict
            if vendor == "postgresql":
                cursor.execute(f"DROP INDEX IF EXISTS {index_name}")
                # For PostgreSQL, we need to drop the constraint if it exists
                cursor.execute(
                    f"""
                    DO $$
                    BEGIN
                        BEGIN
                            ALTER TABLE {table_name} DROP CONSTRAINT {constraint_name};
                        EXCEPTION WHEN undefined_object THEN
                            -- Do nothing, constraint doesn't exist
                        END;
                    END $$;
                """
                )
                # Add unique constraint
                cursor.execute(f"ALTER TABLE {table_name} ADD CONSTRAINT {constraint_name} UNIQUE ({column_name})")
                # Create the like index
                cursor.execute(
                    f"CREATE INDEX {index_name} ON {table_name} USING btree ({column_name} varchar_pattern_ops)"
                )

            elif vendor == "mysql":
                # For MySQL, try to drop and recreate
                try:
                    cursor.execute(f"DROP INDEX {index_name} ON {table_name}")
                except Exception:
                    pass
                try:
                    cursor.execute(f"DROP INDEX {constraint_name} ON {table_name}")
                except Exception:
                    pass

                # Add unique constraint
                cursor.execute(f"ALTER TABLE {table_name} ADD UNIQUE ({column_name})")
                # Create the index
                cursor.execute(f"CREATE INDEX {index_name} ON {table_name} ({column_name})")

            elif vendor == "sqlite":
                # SQLite doesn't support adding constraints after table creation
                # Let Django's migration framework handle this with state operations
                pass
    except Exception:
        # If there's any error, let the migration continue
        # The constraint might already exist
        pass


class Migration(migrations.Migration):

    dependencies = [
        ("web", "0051_teamgoalmember_completion_image_and_more"),
    ]

    operations = [
        # Add the slug field if it doesn't exist
        migrations.RunPython(code=add_slug_column_if_not_exists, reverse_code=migrations.RunPython.noop),
        # Update the Django state to include the field
        migrations.SeparateDatabaseAndState(
            database_operations=[],  # Already handled above
            state_operations=[
                migrations.AddField(
                    model_name="meme",
                    name="slug",
                    field=models.SlugField(blank=True, default="", max_length=255),
                    preserve_default=False,
                ),
            ],
        ),
        # Populate the slugs for any records that don't have them
        migrations.RunPython(code=populate_meme_slugs, reverse_code=migrations.RunPython.noop),
        # Handle unique constraint and indices
        migrations.RunPython(code=handle_unique_constraint, reverse_code=migrations.RunPython.noop),
        # Update Django state to make the field unique
        migrations.SeparateDatabaseAndState(
            database_operations=[],  # Already handled above
            state_operations=[
                migrations.AlterField(
                    model_name="meme",
                    name="slug",
                    field=models.SlugField(blank=True, max_length=255, unique=True),
                ),
            ],
        ),
    ]
