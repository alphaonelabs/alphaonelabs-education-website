{% extends "base.html" %}

{% block title %}
  Advanced Whiteboard
{% endblock title %}
{% block content %}
  <div class="container mx-auto p-4">
    <h1 class="text-2xl font-bold mb-4">Advanced Whiteboard</h1>
    <!-- TOAST notification container with accessibility attributes -->
    <div id="toast-container"
         class="fixed top-4 right-4 z-50 space-y-2"
         aria-live="polite"
         role="region"
         aria-atomic="true"></div>
    <!-- Toolbar -->
    <div class="flex flex-wrap items-center gap-4 mb-4">
      <div class="flex items-center gap-2">
        <label for="toolSelect" class="font-medium">Tool:</label>
        <select id="toolSelect"
                class="border rounded p-1 dark:bg-gray-800 dark:text-white">
          <option value="pen">Pen</option>
          <option value="eraser">Eraser</option>
          <option value="highlighter">Highlighter</option>
          <option value="line">Line</option>
          <option value="rectangle">Rectangle</option>
          <option value="circle">Circle</option>
          <option value="text">Text</option>
          <option value="arrow">Arrow</option>
        </select>
      </div>
      <!-- Color picker -->
      <div class="flex items-center gap-2">
        <label for="penColor" class="font-medium">Color:</label>
        <input type="color" id="penColor" value="#000000" class="border rounded p-1" />
      </div>
      <!-- Pen width -->
      <div class="flex items-center gap-2">
        <label for="penWidth" class="font-medium">Width:</label>
        <input type="range" id="penWidth" min="1" max="10" value="2" class="w-24" />
      </div>
      <!-- Image Scale (for background image) -->
      <div class="flex items-center gap-2">
        <label for="imageScale" class="font-medium">Image Scale (%):</label>
        <input type="range"
               id="imageScale"
               min="10"
               max="300"
               value="100"
               class="w-24" />
      </div>
      <!-- Upload (Load) and Download buttons -->
      <button id="uploadBoard"
              class="px-4 py-2 bg-indigo-500 text-white rounded hover:bg-indigo-600">Load Image</button>
      <input type="file" id="loadInput" accept="image/*" style="display: none;" />
      <button id="downloadBoard"
              class="px-4 py-2 bg-purple-500 text-white rounded hover:bg-purple-600">Download</button>
      <!-- Clear button -->
      <button id="clearBoard"
              class="px-4 py-2 bg-red-500 text-white rounded hover:bg-red-600">Clear</button>
    </div>
    <!-- Canvas -->
    <div class="overflow-auto">
      <canvas id="whiteboard"
              class="border border-gray-300"
              width="1500"
              height="600">
        Your browser does not support the HTML5 canvas.
      </canvas>
    </div>
  </div>
  <script>
      const canvas = document.getElementById('whiteboard');
      const ctx = canvas.getContext('2d');
      let drawing = false;
      let startX = 0;
      let startY = 0;
      let snapshot = null;
      const toolSelect = document.getElementById('toolSelect');
      const penColorInput = document.getElementById('penColor');
      const penWidthInput = document.getElementById('penWidth');
      const imageScaleInput = document.getElementById('imageScale');
      const clearBtn = document.getElementById('clearBoard');
      const uploadBtn = document.getElementById('uploadBoard');
      const loadInput = document.getElementById('loadInput');
      const downloadBtn = document.getElementById('downloadBoard');
      let currentTool = toolSelect.value;
      let penColor = penColorInput.value;
      let penWidth = parseInt(penWidthInput.value, 10);
      let imageScale = 1.0;
      let uploadedImage = null;

      function showToast(message, type = 'error', duration = 5000) {
          const container = document.getElementById('toast-container');
          const toast = document.createElement('div');

          // Set color classes based on project palette with dark mode support
          let bgColorClass;
          if (type === 'error') {
              bgColorClass = 'bg-red-600 dark:bg-red-700';
          } else if (type === 'success') {
              bgColorClass = 'bg-green-600 dark:bg-green-700';
          } else {
              bgColorClass = 'bg-blue-500 dark:bg-blue-600';
          }

          toast.className = `${bgColorClass} text-white px-4 py-3 rounded shadow-lg transform transition-all duration-300 opacity-100 translate-x-0 flex items-center justify-between max-w-md`;

          if (type === 'error') {
              toast.setAttribute('role', 'alert');
              toast.setAttribute('aria-live', 'assertive');
          } else {
              toast.setAttribute('role', 'status');
              toast.setAttribute('aria-live', 'polite');
          }
          toast.setAttribute('aria-atomic', 'true');

          // Create message span safely using textContent
          const span = document.createElement('span');
          span.textContent = message;

          // Create close button safely
          const closeBtn = document.createElement('button');
          closeBtn.textContent = 'âœ•';
          closeBtn.className = 'ml-4 text-white hover:text-gray-200';
          closeBtn.setAttribute('aria-label', 'Close notification');
          closeBtn.addEventListener('click', () => {
              toast.remove();
          });

          toast.appendChild(span);
          toast.appendChild(closeBtn);
          container.appendChild(toast);

          setTimeout(() => {
              if (toast.parentElement) {
                  toast.classList.remove('opacity-100', 'translate-x-0');
                  toast.classList.add('opacity-0', 'translate-x-full');
                  setTimeout(() => toast.remove(), 300);
              }
          }, duration);
      }

      toolSelect.addEventListener('change', function() {
          currentTool = this.value;
          if (currentTool === 'pen') {
              ctx.globalCompositeOperation = 'source-over';
              ctx.globalAlpha = 1.0;
          } else if (currentTool === 'highlighter') {
              ctx.globalCompositeOperation = 'source-over';
              ctx.globalAlpha = 0.3;
          } else if (currentTool === 'eraser') {
              ctx.globalCompositeOperation = 'destination-out';
              ctx.globalAlpha = 1.0;
          } else {
              ctx.globalCompositeOperation = 'source-over';
              ctx.globalAlpha = 1.0;
          }
      });

      penColorInput.addEventListener('change', function() {
          penColor = this.value;
      });

      penWidthInput.addEventListener('input', function() {
          penWidth = parseInt(this.value, 10);
      });
      imageScaleInput.addEventListener('input', function() {
          imageScale = parseInt(this.value, 10) / 100;
          if (uploadedImage) {
              redrawBackground();
              scheduleSave();
          }
      });
      clearBtn.addEventListener('click', () => {
          ctx.clearRect(0, 0, canvas.width, canvas.height);
          uploadedImage = null;
          saveCanvas();
          showToast('Canvas cleared', 'success', 2000);
      });
      uploadBtn.addEventListener('click', () => {
          loadInput.click();
      });
      loadInput.addEventListener('change', (event) => {
          const file = event.target.files[0];
          if (!file) return;

          const reader = new FileReader();
          reader.onload = function(e) {
              const dataURL = e.target.result;
              const img = new Image();
              img.src = dataURL;
              img.onload = function() {
                  uploadedImage = img;
                  imageScale = parseInt(imageScaleInput.value, 10) / 100;
                  redrawBackground();
                  saveCanvas();
                  showToast('Image loaded successfully', 'success', 2000);
              };
          };
          reader.readAsDataURL(file);
      });

      function redrawBackground() {
          ctx.clearRect(0, 0, canvas.width, canvas.height);
          const newWidth = uploadedImage.width * imageScale;
          const newHeight = uploadedImage.height * imageScale;
          ctx.drawImage(uploadedImage, 0, 0, newWidth, newHeight);
      }

      // Persistence and cross-tab sync:
      const STORAGE_KEY = 'whiteboardData';
      let saveScheduled = null;
      let broadcastChannel = null;

      // Initialize BroadcastChannel
      if (window.BroadcastChannel) {
          try {
              broadcastChannel = new BroadcastChannel('whiteboard_channel');
              broadcastChannel.addEventListener('message', (ev) => {
                  if (ev.data && ev.data.data) {
                      loadCanvasFromDataURL(ev.data.data);
                  }
              });
          } catch (e) {
              console.warn('Could not open BroadcastChannel', e);
          }
      } else {
          // Storage event fallback for browsers without BroadcastChannel:
          window.addEventListener('storage', (e) => {
              if (e.key !== STORAGE_KEY) return;
              try {
                  const payload = JSON.parse(e.newValue || '{}');
                  if (payload && payload.data) {
                      loadCanvasFromDataURL(payload.data);
                  }
              } catch (err) {
                  console.warn('Failed to parse storage event payload', err);
              }
          });
      }

      function saveCanvas() {
          const data = canvas.toDataURL('image/png');
          const ts = Date.now();
          let savedToStorage = false;

          try {
              const dataString = JSON.stringify({
                  ts,
                  data
              });

              // Single consistent check using dataString.length (what localStorage actually uses)
              if (dataString.length > 4.5 * 1024 * 1024) { // >4.5MB character count
                  showToast('Warning: Canvas too large for browser storage. Consider downloading your work.', 'error', 5000);
              } else {
                  localStorage.setItem(STORAGE_KEY, dataString);
                  savedToStorage = true;
              }
          } catch (err) {
              console.warn('Failed to save whiteboard to localStorage', err);
              showToast('Failed to auto-save. Please download your work manually.', 'error', 8000);
          }

          if (broadcastChannel) {
              try {
                  broadcastChannel.postMessage({
                      ts,
                      data
                  });
              } catch (e) {
                  console.warn('BroadcastChannel error', e);
              }
          }

          if (saveScheduled) {
              clearTimeout(saveScheduled);
              saveScheduled = null;
          }
      }

      function scheduleSave(delay = 250) {
          if (saveScheduled) return;
          saveScheduled = setTimeout(() => {
              saveScheduled = null;
              saveCanvas();
          }, delay);
      }

      function loadCanvasFromDataURL(dataURL) {
          if (!dataURL) return;
          const img = new Image();

          img.onload = function() {
              ctx.save();
              ctx.globalCompositeOperation = 'source-over';
              ctx.globalAlpha = 1.0;
              ctx.clearRect(0, 0, canvas.width, canvas.height);
              ctx.drawImage(img, 0, 0, canvas.width, canvas.height);
              ctx.restore();
          };

          img.onerror = function() {
              console.warn('Failed to load canvas image from dataURL');
              showToast('Failed to load canvas image', 'error', 5000);
          };
          img.src = dataURL;
      }

      window.addEventListener('load', () => {
          try {
              const raw = localStorage.getItem(STORAGE_KEY);
              if (raw) {
                  const payload = JSON.parse(raw);
                  if (payload && payload.data) {
                      loadCanvasFromDataURL(payload.data);
                      return;
                  }
              }
          } catch (err) {
              console.warn('Error loading saved whiteboard', err);
              showToast('Failed to load saved whiteboard', 'error', 5000);
          }

          // Fallback to older single-image storage key
          const dataURL = localStorage.getItem('whiteboardImage');
          if (dataURL) {
              const img = new Image();
              img.src = dataURL;
              img.onload = function() {
                  uploadedImage = img;
                  imageScale = parseInt(imageScaleInput.value, 10) / 100;
                  redrawBackground();
              };
              img.onerror = function() {
                  console.warn('Failed to load fallback image');
              };
          }
      });

      downloadBtn.addEventListener('click', () => {
          const dataURL = canvas.toDataURL("image/png");
          const link = document.createElement('a');
          link.href = dataURL;
          link.download = "whiteboard.png";
          link.click();
          showToast('Download started', 'success', 2000);
      });

      function takeSnapshot() {
          snapshot = ctx.getImageData(0, 0, canvas.width, canvas.height);
      }

      function restoreSnapshot() {
          if (snapshot) {
              ctx.putImageData(snapshot, 0, 0);
          }
      }

      function drawArrow(fromX, fromY, toX, toY) {
          const headlen = 10;
          const angle = Math.atan2(toY - fromY, toX - fromX);
          ctx.beginPath();
          ctx.moveTo(fromX, fromY);
          ctx.lineTo(toX, toY);
          ctx.stroke();
          ctx.beginPath();
          ctx.moveTo(toX, toY);
          ctx.lineTo(toX - headlen * Math.cos(angle - Math.PI / 6), toY - headlen * Math.sin(angle - Math.PI / 6));
          ctx.lineTo(toX - headlen * Math.cos(angle + Math.PI / 6), toY - headlen * Math.sin(angle + Math.PI / 6));
          ctx.lineTo(toX, toY);
          ctx.lineTo(toX - headlen * Math.cos(angle - Math.PI / 6), toY - headlen * Math.sin(angle - Math.PI / 6));
          ctx.stroke();
      }

      canvas.addEventListener('mousedown', (e) => {
          drawing = true;
          startX = e.offsetX;
          startY = e.offsetY;

          if (currentTool === 'pen' || currentTool === 'eraser' || currentTool === 'highlighter') {
              ctx.beginPath();
              ctx.moveTo(startX, startY);
          } else if (currentTool === 'text') {
              const text = prompt("Enter text to add:");
              if (text) {
                  ctx.font = `${penWidth * 5}px sans-serif`;
                  ctx.fillStyle = penColor;
                  ctx.fillText(text, startX, startY);
              }
              drawing = false;
          } else {
              takeSnapshot();
          }
      });

      canvas.addEventListener('mousemove', (e) => {
          if (!drawing) return;
          const currentX = e.offsetX;
          const currentY = e.offsetY;

          if (currentTool === 'pen' || currentTool === 'eraser' || currentTool === 'highlighter') {
              if (currentTool === 'eraser') {
                  ctx.globalCompositeOperation = 'destination-out';
                  ctx.globalAlpha = 1.0;
              } else if (currentTool === 'pen') {
                  ctx.globalCompositeOperation = 'source-over';
                  ctx.strokeStyle = penColor;
                  ctx.globalAlpha = 1.0;
              } else if (currentTool === 'highlighter') {
                  ctx.globalCompositeOperation = 'source-over';
                  ctx.strokeStyle = penColor;
                  ctx.globalAlpha = 0.3;
              }
              ctx.lineWidth = penWidth;
              ctx.lineTo(currentX, currentY);
              ctx.stroke();
          } else if (currentTool === 'line' || currentTool === 'rectangle' || currentTool === 'circle' || currentTool === 'arrow') {
              restoreSnapshot();
              ctx.globalCompositeOperation = 'source-over';
              ctx.lineWidth = penWidth;
              ctx.strokeStyle = penColor;

              if (currentTool === 'line') {
                  ctx.beginPath();
                  ctx.moveTo(startX, startY);
                  ctx.lineTo(currentX, currentY);
                  ctx.stroke();
              } else if (currentTool === 'rectangle') {
                  const width = currentX - startX;
                  const height = currentY - startY;
                  ctx.strokeRect(startX, startY, width, height);
              } else if (currentTool === 'circle') {
                  const radius = Math.sqrt(Math.pow(currentX - startX, 2) + Math.pow(currentY - startY, 2));
                  ctx.beginPath();
                  ctx.arc(startX, startY, radius, 0, Math.PI * 2);
                  ctx.stroke();
              } else if (currentTool === 'arrow') {
                  ctx.beginPath();
                  ctx.moveTo(startX, startY);
                  ctx.lineTo(currentX, currentY);
                  ctx.stroke();
              }
          }
      });

      canvas.addEventListener('mouseup', (e) => {
          if (!drawing) return;
          drawing = false;
          const currentX = e.offsetX;
          const currentY = e.offsetY;

          if (currentTool === 'line') {
              restoreSnapshot();
              ctx.globalCompositeOperation = 'source-over';
              ctx.beginPath();
              ctx.moveTo(startX, startY);
              ctx.lineTo(currentX, currentY);
              ctx.stroke();
          } else if (currentTool === 'rectangle') {
              restoreSnapshot();
              ctx.globalCompositeOperation = 'source-over';
              const width = currentX - startX;
              const height = currentY - startY;
              ctx.strokeRect(startX, startY, width, height);
          } else if (currentTool === 'circle') {
              restoreSnapshot();
              ctx.globalCompositeOperation = 'source-over';
              const radius = Math.sqrt(Math.pow(currentX - startX, 2) + Math.pow(currentY - startY, 2));
              ctx.beginPath();
              ctx.arc(startX, startY, radius, 0, Math.PI * 2);
              ctx.stroke();
          } else if (currentTool === 'arrow') {
              restoreSnapshot();
              ctx.globalCompositeOperation = 'source-over';
              drawArrow(startX, startY, currentX, currentY);
          }
          // Save and sync after completing a stroke/shape
          scheduleSave(250);
      });

      canvas.addEventListener('mouseleave', () => {
          drawing = false;
      });
  </script>
{% endblock content %}
