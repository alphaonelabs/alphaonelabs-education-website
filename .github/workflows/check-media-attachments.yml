name: Check PR for media attachments when HTML files change

on:
  pull_request:
    types: [opened, synchronize]
    # optionally: [opened, synchronize, reopened]

jobs:
  check-media-attachments:
    runs-on: ubuntu-latest
    name: Check media attachments in HTML files
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Check for media attachments in HTML files
        uses: actions/github-script@v6
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const { owner, repo } = context.repo;
            const { number } = context.payload.pull_request;
            
            console.log(`Checking PR #${number} for media attachments in HTML files`);
            
            // Get the list of files changed in this PR
            const { data: files } = await github.rest.pulls.listFiles({
              owner,
              repo,
              pull_number: number
            });
            
            // Filter for HTML files that were added or modified
            const htmlFiles = files.filter(file => 
              file.filename.endsWith('.html') && 
              (file.status === 'added' || file.status === 'modified')
            );
            
            if (htmlFiles.length === 0) {
              console.log('No HTML files were changed in this PR.');
              return;
            }
            
            console.log(`Found ${htmlFiles.length} HTML file(s) to check:`);
            htmlFiles.forEach(file => console.log(`- ${file.filename}`));
            
            let hasIssues = false;
            const issues = [];
            const mediaReferences = [];
            
            for (const file of htmlFiles) {
              console.log(`\nAnalyzing ${file.filename}...`);
              
              try {
                // Get file content from the PR branch
                const { data: fileData } = await github.rest.repos.getContent({
                  owner,
                  repo,
                  path: file.filename,
                  ref: context.payload.pull_request.head.sha
                });
                
                const content = Buffer.from(fileData.content, 'base64').toString('utf8');
                
                // Check for images without alt attributes
                const imgWithoutAlt = content.match(/<img(?![^>]*\salt=)[^>]*>/gi);
                if (imgWithoutAlt && imgWithoutAlt.length > 0) {
                  hasIssues = true;
                  issues.push(`**${file.filename}**: Found ${imgWithoutAlt.length} image(s) without alt attributes`);
                  console.log(`  - Found ${imgWithoutAlt.length} img tag(s) without alt attributes`);
                }
                
                // Check for media files referenced
                const mediaMatches = content.match(/(src|href)=["'][^"']*\.(jpg|jpeg|png|gif|webp|svg|mp4|avi|mov|pdf)["']/gi);
                if (mediaMatches && mediaMatches.length > 0) {
                  mediaReferences.push(`**${file.filename}**: References ${mediaMatches.length} media file(s)`);
                  console.log(`  - Found ${mediaMatches.length} media reference(s)`);
                  
                  // Check for large image formats that could be optimized
                  const unoptimizedImages = mediaMatches.filter(match => 
                    /\.(jpg|jpeg|png)["']/i.test(match)
                  );
                  if (unoptimizedImages.length > 0) {
                    issues.push(`**${file.filename}**: Consider using WebP format for ${unoptimizedImages.length} image(s) for better performance`);
                  }
                }
                
                // Check for missing figure captions for accessibility
                const figuresWithoutCaption = content.match(/<figure(?![^>]*<figcaption)[^>]*>[\s\S]*?<\/figure>/gi);
                if (figuresWithoutCaption && figuresWithoutCaption.length > 0) {
                  issues.push(`**${file.filename}**: Found ${figuresWithoutCaption.length} figure(s) without figcaption for accessibility`);
                }
                
              } catch (error) {
                console.error(`Error processing ${file.filename}: ${error.message}`);
                issues.push(`**${file.filename}**: Could not analyze file - ${error.message}`);
              }
            }
            
            // Create summary comment
            let commentBody = '## üì∏ Media Attachments Analysis\n\n';
            
            if (mediaReferences.length > 0) {
              commentBody += '### Media Files Found\n';
              commentBody += mediaReferences.map(ref => `- ${ref}`).join('\n') + '\n\n';
            }
            
            if (hasIssues) {
              commentBody += '### ‚ö†Ô∏è Issues Found\n';
              commentBody += issues.map(issue => `- ${issue}`).join('\n') + '\n\n';
              commentBody += '**Recommendations:**\n';
              commentBody += '- Add `alt` attributes to all images for accessibility\n';
              commentBody += '- Consider using WebP format for better performance\n';
              commentBody += '- Add `<figcaption>` to `<figure>` elements for screen readers\n\n';
            } else {
              commentBody += '### ‚úÖ All Checks Passed\n';
              commentBody += 'No media-related issues found in the HTML files.\n\n';
            }
            
            commentBody += '*This check was automatically performed when HTML files were modified.*';
            
            // Check if we already commented on this PR
            const { data: comments } = await github.rest.issues.listComments({
              owner,
              repo,
              issue_number: number,
            });
            
            const botComment = comments.find(comment =>
              comment.user.login === 'github-actions[bot]' &&
              comment.body.includes('üì∏ Media Attachments Analysis')
            );
            
            if (botComment) {
              // Update existing comment
              await github.rest.issues.updateComment({
                owner,
                repo,
                comment_id: botComment.id,
                body: commentBody
              });
              console.log('Updated existing media attachments comment');
            } else {
              // Create new comment
              await github.rest.issues.createComment({
                owner,
                repo,
                issue_number: number,
                body: commentBody
              });
              console.log('Created new media attachments comment');
            }
            
            // Don't fail the workflow, just inform
            if (hasIssues) {
              console.log('‚ö†Ô∏è Media attachment issues found, but not failing the workflow');
            } else {
              console.log('‚úÖ All media attachment checks passed!');
            }